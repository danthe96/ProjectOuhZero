package editor;

import java.util.ArrayList;

import com.jme3.asset.AssetManager;
import com.jme3.math.Vector3f;
import com.jme3.scene.Node;
import com.jme3.scene.Spatial;


public class WallNode extends Node {
	public int[] openRoomEndDimensions= new int[3]; //In diesem Bereich ist immer Nichts. (Spart VIEL Rechenleistung)
	public int[] openRoomStartDimensions = {1,1,1};
	
	public WallNode(String string) {
		super(string);
	}

	boolean isPlot(int x,int y, int z) {
		if (isOpenRoom(x, y, z)) return true;
		return isActualPlot(x,y,z);
	}

	boolean isActualPlot(int x,int y, int z) {
		return isActualPlot(RoomNode.genName(x, y, z));
	}
	
	boolean isActualPlot(String genName) {
		return getChild(genName) != null;
	}

	boolean isPlot(String s) {
		
		return false;
	}

	public boolean isOpenRoom(int x, int y, int z) {
		if (x<openRoomStartDimensions[0] || x > openRoomEndDimensions[0]) return false; 
		if (y<openRoomStartDimensions[1] || y > openRoomEndDimensions[1]) return false; 
		if (z<openRoomStartDimensions[2] || z > openRoomEndDimensions[2]) return false; 
		return true;
	}

	public void addAndUpdate(RoomNode roomNode,AssetManager am) {
		attachChild(roomNode);
		roomNode.updateWall(this, am);
		for (String s: roomNode.getNeighbors()) {
			try {
				((RoomNode)getChild(s)).updateWall(this, am);
			}
			catch( Exception e) {}
		}
		
	}
	public void generateRoom(AssetManager am, int[] startvalues, int[] endvalues) {
		
		for (int x=startvalues[0]; x<=endvalues[0]+1; x++)
			for (int y=startvalues[1]; y<=endvalues[1]+1; y++)
				for (int z=startvalues[2]; z<=endvalues[2]+1; z++)  {
					if (!isOpenRoom(x,y,z)) getOrCreateRoomNode(x, y, z);
				}
		for (Spatial s: getChildren()) {
			((RoomNode) s).updateWall(wallnode, assetManager);
		}
		
		
	}

	
	
	public void removeBlock(Vector3f coordsByGeometry, AssetManager assetManager) {
		removeBlock((int)(coordsByGeometry.x/RoomNode.factor),(int)(coordsByGeometry.y/RoomNode.factor),(int)(coordsByGeometry.z/RoomNode.factor), assetManager);
		
	}

	public void removeBlock(int x, int y, int z, AssetManager am) {
		RoomNode r = (RoomNode) getChild(RoomNode.genName(x, y, z));
		detachChild(r);
		for (int[] a: r.getNeighborsCoords()) {
			if (isActualPlot(a[0],a[1],a[2])) ((RoomNode) getChild(RoomNode.genName(a))).updateWall(this, am);
			if (isPlot(a[0],a[1],a[2]) && !isActualPlot(a[0],a[1],a[2])) reduceOpenRoom(a, am);
		}
	}

	private void reduceOpenRoom(int[] a, AssetManager am) {
		RoomNode r;
		int[] startcopy = openRoomStartDimensions;
		int[] endcopy = openRoomEndDimensions;
		
		for (int i=0; i<3; i++) {
			if (a[i] == openRoomStartDimensions[i]) openRoomStartDimensions[i]++;
			if (a[i] == openRoomEndDimensions[i]) openRoomEndDimensions[i]--;
		}
		
		System.out.println(a[0]+" "+a[1]+" "+a[2]);
		System.out.println(openRoomStartDimensions[0]+" "+openRoomStartDimensions[1]+" "+openRoomStartDimensions[2]);
		System.out.println(openRoomEndDimensions[0]+" "+openRoomEndDimensions[1]+" "+openRoomEndDimensions[2]);
	}
}
